<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TETRIX</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

  :root {
    --bg: #060810;
    --panel: #0a0f1e;
    --border: #1a2a4a;
    --glow-cyan: #00f5ff;
    --glow-pink: #ff006e;
    --glow-yellow: #ffbe0b;
    --text: #c8d8f0;
    --dim: #3a4a6a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    position: relative;
  }

  /* Scanline overlay */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.08) 2px,
      rgba(0,0,0,0.08) 4px
    );
    pointer-events: none;
    z-index: 100;
  }

  /* Grid background */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,245,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,245,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
  }

  .wrapper {
    display: flex;
    gap: 24px;
    align-items: flex-start;
    position: relative;
    z-index: 1;
  }

  /* Side panel shared styles */
  .side-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 160px;
  }

  .panel-box {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 16px;
    position: relative;
    overflow: hidden;
  }

  .panel-box::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--glow-cyan), transparent);
    opacity: 0.6;
  }

  .panel-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    font-weight: 700;
    letter-spacing: 3px;
    color: var(--dim);
    text-transform: uppercase;
    margin-bottom: 12px;
  }

  .panel-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 26px;
    font-weight: 900;
    color: var(--glow-cyan);
    text-shadow: 0 0 20px var(--glow-cyan), 0 0 40px rgba(0,245,255,0.4);
    letter-spacing: 2px;
    line-height: 1;
  }

  .panel-value.pink {
    color: var(--glow-pink);
    text-shadow: 0 0 20px var(--glow-pink), 0 0 40px rgba(255,0,110,0.4);
  }

  /* Main game area */
  .game-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0;
  }

  .game-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 32px;
    font-weight: 900;
    letter-spacing: 12px;
    color: transparent;
    background: linear-gradient(135deg, var(--glow-cyan), var(--glow-pink));
    -webkit-background-clip: text;
    background-clip: text;
    text-shadow: none;
    filter: drop-shadow(0 0 20px rgba(0,245,255,0.5));
    margin-bottom: 16px;
  }

  #game-canvas {
    display: block;
    border: 1px solid var(--border);
    box-shadow:
      0 0 0 1px rgba(0,245,255,0.1),
      0 0 40px rgba(0,245,255,0.15),
      inset 0 0 60px rgba(0,0,0,0.8);
    image-rendering: pixelated;
  }

  /* Next piece canvas */
  #next-canvas {
    display: block;
    margin: 0 auto;
  }

  /* Controls hint */
  .controls {
    margin-top: 16px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .ctrl-row {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 10px;
    color: var(--dim);
    letter-spacing: 1px;
  }

  .key {
    background: var(--border);
    border: 1px solid var(--dim);
    border-radius: 3px;
    padding: 2px 6px;
    font-size: 9px;
    color: var(--text);
    min-width: 28px;
    text-align: center;
  }

  /* Overlay */
  #overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(6,8,16,0.88);
    z-index: 10;
    backdrop-filter: blur(2px);
  }

  #overlay.hidden { display: none; }

  .overlay-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 28px;
    font-weight: 900;
    letter-spacing: 6px;
    color: var(--glow-cyan);
    text-shadow: 0 0 30px var(--glow-cyan);
    margin-bottom: 8px;
    animation: pulse 1.5s ease-in-out infinite;
  }

  .overlay-title.gameover {
    color: var(--glow-pink);
    text-shadow: 0 0 30px var(--glow-pink);
  }

  .overlay-sub {
    font-size: 11px;
    letter-spacing: 3px;
    color: var(--dim);
    margin-bottom: 24px;
  }

  .start-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    font-weight: 700;
    letter-spacing: 4px;
    color: var(--bg);
    background: var(--glow-cyan);
    border: none;
    padding: 12px 28px;
    border-radius: 2px;
    cursor: pointer;
    text-transform: uppercase;
    box-shadow: 0 0 20px rgba(0,245,255,0.5);
    transition: all 0.2s;
  }

  .start-btn:hover {
    background: #fff;
    box-shadow: 0 0 40px rgba(0,245,255,0.9);
    transform: scale(1.04);
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  /* Timer */
  .timer-value {
    font-size: 30px;
    transition: color 0.3s, text-shadow 0.3s;
  }
  .timer-value.warning {
    color: var(--glow-yellow) !important;
    text-shadow: 0 0 20px var(--glow-yellow), 0 0 40px rgba(255,190,11,0.5) !important;
    animation: timerPulse 0.6s ease-in-out infinite;
  }
  .timer-value.danger {
    color: var(--glow-pink) !important;
    text-shadow: 0 0 20px var(--glow-pink), 0 0 40px rgba(255,0,110,0.5) !important;
    animation: timerPulse 0.3s ease-in-out infinite;
  }
  @keyframes timerPulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.05); }
  }

  .timer-bar-bg {
    height: 4px;
    background: rgba(255,255,255,0.08);
    border-radius: 2px;
    margin-top: 10px;
    overflow: hidden;
  }
  .timer-bar {
    height: 100%;
    width: 100%;
    background: var(--glow-cyan);
    border-radius: 2px;
    box-shadow: 0 0 8px var(--glow-cyan);
    transition: width 0.5s linear, background 0.3s;
  }
  .timer-bar.warning { background: var(--glow-yellow); box-shadow: 0 0 8px var(--glow-yellow); }
  .timer-bar.danger  { background: var(--glow-pink);   box-shadow: 0 0 8px var(--glow-pink); }

  /* Time Up overlay extras */
  .overlay-score-box {
    background: rgba(0,245,255,0.06);
    border: 1px solid rgba(0,245,255,0.2);
    border-radius: 4px;
    padding: 16px 32px;
    margin-bottom: 20px;
    text-align: center;
  }
  .overlay-score-label {
    font-size: 9px;
    letter-spacing: 3px;
    color: var(--dim);
    margin-bottom: 6px;
  }
  .overlay-score-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 36px;
    font-weight: 900;
    color: var(--glow-cyan);
    text-shadow: 0 0 30px var(--glow-cyan);
    letter-spacing: 4px;
  }
  .overlay-stats {
    display: flex;
    gap: 24px;
    margin-bottom: 24px;
  }
  .overlay-stat {
    text-align: center;
  }
  .overlay-stat-label {
    font-size: 8px;
    letter-spacing: 2px;
    color: var(--dim);
    margin-bottom: 4px;
  }
  .overlay-stat-val {
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    font-weight: 700;
    color: var(--text);
    letter-spacing: 1px;
  }
  .overlay-hi {
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--glow-yellow);
    margin-bottom: 20px;
    text-shadow: 0 0 10px var(--glow-yellow);
  }
  .timeup-flash {
    animation: timeupFlash 0.5s ease-out;
  }
  @keyframes timeupFlash {
    0% { background: rgba(255,0,110,0.3); }
    100% { background: rgba(6,8,16,0.88); }
  }

  /* High score */
  .hi-label {
    font-size: 8px;
    letter-spacing: 2px;
    color: var(--glow-yellow);
    margin-bottom: 4px;
    opacity: 0.8;
  }

  .hi-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    font-weight: 700;
    color: var(--glow-yellow);
    text-shadow: 0 0 12px var(--glow-yellow);
  }

  /* Line clear flash */
  @keyframes lineFlash {
    0% { opacity: 1; }
    50% { opacity: 0.2; }
    100% { opacity: 1; }
  }

  /* Mobile touch buttons */
  .touch-controls {
    display: none;
    margin-top: 16px;
    gap: 8px;
  }

  .touch-btn {
    font-family: 'Orbitron', sans-serif;
    background: var(--panel);
    border: 1px solid var(--border);
    color: var(--glow-cyan);
    font-size: 18px;
    width: 52px;
    height: 52px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
    transition: background 0.1s;
  }

  .touch-btn:active {
    background: rgba(0,245,255,0.15);
  }

  @media (max-width: 600px) {
    .touch-controls { display: flex; flex-wrap: wrap; justify-content: center; }
    .side-panel { display: none; }
    .wrapper { gap: 0; }
  }
</style>
</head>
<body>

<div class="wrapper">
  <!-- Left panel -->
  <div class="side-panel">
    <div class="panel-box timer-box" id="timer-box">
      <div class="panel-label">Time</div>
      <div class="panel-value timer-value" id="timer-display">5:00</div>
      <div class="timer-bar-bg"><div class="timer-bar" id="timer-bar"></div></div>
    </div>
    <div class="panel-box">
      <div class="panel-label">Score</div>
      <div class="panel-value" id="score-display">0</div>
    </div>
    <div class="panel-box">
      <div class="panel-label">Level</div>
      <div class="panel-value pink" id="level-display">1</div>
    </div>
    <div class="panel-box">
      <div class="panel-label">Lines</div>
      <div class="panel-value" id="lines-display">0</div>
    </div>
    <div class="panel-box">
      <div class="hi-label">HIGH SCORE</div>
      <div class="hi-value" id="hi-display">0</div>
    </div>
  </div>

  <!-- Center: game -->
  <div class="game-area">
    <div class="game-title">TETRIX</div>
    <div style="position:relative;">
      <canvas id="game-canvas" width="300" height="600"></canvas>
      <div id="overlay">
        <div class="overlay-title" id="overlay-title">TETRIX</div>
        <div class="overlay-sub" id="overlay-sub">PRESS START TO PLAY</div>
        <div class="overlay-score-box" id="overlay-result" style="display:none;">
          <div class="overlay-score-label">FINAL SCORE</div>
          <div class="overlay-score-value" id="overlay-final-score">0</div>
        </div>
        <div class="overlay-stats" id="overlay-stats" style="display:none;">
          <div class="overlay-stat">
            <div class="overlay-stat-label">LINES</div>
            <div class="overlay-stat-val" id="overlay-final-lines">0</div>
          </div>
          <div class="overlay-stat">
            <div class="overlay-stat-label">LEVEL</div>
            <div class="overlay-stat-val" id="overlay-final-level">1</div>
          </div>
        </div>
        <div class="overlay-hi" id="overlay-hi-msg" style="display:none;"></div>
        <button class="start-btn" id="start-btn">START</button>
      </div>
    </div>
    <div class="touch-controls" id="touch-controls">
      <button class="touch-btn" id="btn-left">◀</button>
      <button class="touch-btn" id="btn-down">▼</button>
      <button class="touch-btn" id="btn-rotate">↻</button>
      <button class="touch-btn" id="btn-right">▶</button>
      <button class="touch-btn" id="btn-drop" style="width:116px;font-size:11px;letter-spacing:2px;">DROP</button>
    </div>
  </div>

  <!-- Right panel -->
  <div class="side-panel">
    <div class="panel-box">
      <div class="panel-label">Next</div>
      <canvas id="next-canvas" width="128" height="128"></canvas>
    </div>
    <div class="panel-box controls">
      <div class="panel-label">Controls</div>
      <div class="ctrl-row"><span class="key">←→</span>Move</div>
      <div class="ctrl-row"><span class="key">↑</span>Rotate</div>
      <div class="ctrl-row"><span class="key">↓</span>Soft drop</div>
      <div class="ctrl-row"><span class="key">SPC</span>Hard drop</div>
      <div class="ctrl-row"><span class="key">P</span>Pause</div>
    </div>
  </div>
</div>

<script>
// ─── Constants ────────────────────────────────────────────────
const COLS = 10, ROWS = 20;
const BLOCK = 30; // cell size in px

const COLORS = {
  I: { fill: '#00f5ff', glow: 'rgba(0,245,255,0.5)' },
  O: { fill: '#ffbe0b', glow: 'rgba(255,190,11,0.5)' },
  T: { fill: '#cc44ff', glow: 'rgba(204,68,255,0.5)' },
  S: { fill: '#00ff88', glow: 'rgba(0,255,136,0.5)' },
  Z: { fill: '#ff006e', glow: 'rgba(255,0,110,0.5)' },
  J: { fill: '#ff7c00', glow: 'rgba(255,124,0,0.5)' },
  L: { fill: '#4488ff', glow: 'rgba(68,136,255,0.5)' },
};

const SHAPES = {
  I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  O: [[1,1],[1,1]],
  T: [[0,1,0],[1,1,1],[0,0,0]],
  S: [[0,1,1],[1,1,0],[0,0,0]],
  Z: [[1,1,0],[0,1,1],[0,0,0]],
  J: [[1,0,0],[1,1,1],[0,0,0]],
  L: [[0,0,1],[1,1,1],[0,0,0]],
};

const TYPES = Object.keys(SHAPES);

// ─── Canvas Setup ─────────────────────────────────────────────
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextCtx = nextCanvas.getContext('2d');

// ─── State ────────────────────────────────────────────────────
const GAME_DURATION = 300; // 5 minutes in seconds

let board, current, next, score, lines, level, hiScore, dropInterval, lastDrop, animId, paused, gameOver;
let timeLeft, lastTimeTick;

function init() {
  board = Array.from({length: ROWS}, () => Array(COLS).fill(null));
  score = 0; lines = 0; level = 1;
  hiScore = parseInt(localStorage.getItem('tetrix_hi') || '0');
  paused = false; gameOver = false;
  timeLeft = GAME_DURATION;
  lastTimeTick = performance.now();
  updateUI();
  updateTimer();
  next = randomPiece();
  spawnPiece();
  dropInterval = 1000;
  lastDrop = performance.now();
  if (animId) cancelAnimationFrame(animId);
  loop(performance.now());
}

function randomPiece() {
  const t = TYPES[Math.floor(Math.random() * TYPES.length)];
  return { type: t, shape: SHAPES[t].map(r => [...r]), x: 3, y: 0 };
}

function spawnPiece() {
  current = next;
  current.x = Math.floor((COLS - current.shape[0].length) / 2);
  current.y = 0;
  next = randomPiece();
  if (collides(current, 0, 0)) { endGame(); }
}

// ─── Collision ────────────────────────────────────────────────
function collides(piece, dx, dy, shape) {
  shape = shape || piece.shape;
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (!shape[r][c]) continue;
      const nx = piece.x + c + dx;
      const ny = piece.y + r + dy;
      if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
      if (ny >= 0 && board[ny][nx]) return true;
    }
  }
  return false;
}

function rotate(shape) {
  const N = shape.length;
  return shape[0].map((_, c) => shape.map((_, r) => shape[N-1-r][c]));
}

// ─── Controls ─────────────────────────────────────────────────
function moveLeft()   { if (!collides(current, -1, 0)) current.x--; }
function moveRight()  { if (!collides(current,  1, 0)) current.x++; }
function moveDown()   {
  if (!collides(current, 0, 1)) { current.y++; }
  else { lock(); }
}
function rotatePiece() {
  const rotated = rotate(current.shape);
  const kicks = [0, -1, 1, -2, 2];
  for (const k of kicks) {
    if (!collides(current, k, 0, rotated)) {
      current.shape = rotated; current.x += k; return;
    }
  }
}
function hardDrop() {
  while (!collides(current, 0, 1)) current.y++;
  lock();
}

// ─── Lock & Clear ─────────────────────────────────────────────
function lock() {
  for (let r = 0; r < current.shape.length; r++) {
    for (let c = 0; c < current.shape[r].length; c++) {
      if (!current.shape[r][c]) continue;
      const row = current.y + r;
      if (row < 0) { endGame(); return; }
      board[row][current.x + c] = current.type;
    }
  }
  clearLines();
  spawnPiece();
}

const LINE_POINTS = [0, 100, 300, 500, 800];

function clearLines() {
  let cleared = 0;
  for (let r = ROWS - 1; r >= 0; r--) {
    if (board[r].every(c => c !== null)) {
      board.splice(r, 1);
      board.unshift(Array(COLS).fill(null));
      cleared++; r++;
    }
  }
  if (cleared > 0) {
    score += LINE_POINTS[cleared] * level;
    lines += cleared;
    level = Math.floor(lines / 10) + 1;
    dropInterval = Math.max(100, 1000 - (level - 1) * 90);
    if (score > hiScore) { hiScore = score; localStorage.setItem('tetrix_hi', hiScore); }
    updateUI();
  }
}

function updateUI() {
  document.getElementById('score-display').textContent = score;
  document.getElementById('level-display').textContent = level;
  document.getElementById('lines-display').textContent = lines;
  document.getElementById('hi-display').textContent = hiScore;
}

function updateTimer() {
  const secs = Math.max(0, Math.ceil(timeLeft));
  const m = Math.floor(secs / 60);
  const s = secs % 60;
  const display = document.getElementById('timer-display');
  const bar = document.getElementById('timer-bar');
  display.textContent = `${m}:${String(s).padStart(2,'0')}`;
  const pct = (timeLeft / GAME_DURATION) * 100;
  bar.style.width = pct + '%';

  // Warning states
  display.classList.remove('warning','danger');
  bar.classList.remove('warning','danger');
  if (timeLeft <= 10) {
    display.classList.add('danger'); bar.classList.add('danger');
  } else if (timeLeft <= 30) {
    display.classList.add('warning'); bar.classList.add('warning');
  }
}

// ─── Game Over ────────────────────────────────────────────────
function showResult(reason) {
  gameOver = true;
  cancelAnimationFrame(animId);

  const isNew = score > 0 && score >= hiScore && lines > 0;

  const ov = document.getElementById('overlay');
  const title = document.getElementById('overlay-title');
  const sub = document.getElementById('overlay-sub');

  title.classList.remove('gameover');
  if (reason === 'timeup') {
    title.textContent = 'TIME UP!';
    title.style.color = 'var(--glow-yellow)';
    title.style.textShadow = '0 0 30px var(--glow-yellow)';
    sub.textContent = '5分間お疲れさまでした！';
    ov.classList.add('timeup-flash');
    setTimeout(() => ov.classList.remove('timeup-flash'), 500);
  } else {
    title.textContent = 'GAME OVER';
    title.classList.add('gameover');
    title.style.color = '';
    title.style.textShadow = '';
    sub.textContent = 'ブロックが天井に到達しました';
  }

  document.getElementById('overlay-final-score').textContent = score.toLocaleString();
  document.getElementById('overlay-final-lines').textContent = lines;
  document.getElementById('overlay-final-level').textContent = level;
  document.getElementById('overlay-result').style.display = 'block';
  document.getElementById('overlay-stats').style.display = 'flex';

  const hiMsg = document.getElementById('overlay-hi-msg');
  if (isNew && score === hiScore) {
    hiMsg.textContent = '★ NEW HIGH SCORE! ★';
    hiMsg.style.display = 'block';
  } else {
    hiMsg.textContent = `BEST: ${hiScore.toLocaleString()}`;
    hiMsg.style.display = 'block';
  }

  document.getElementById('start-btn').textContent = 'PLAY AGAIN';
  ov.classList.remove('hidden');
}

function endGame() { showResult('stack'); }

// ─── Drawing ──────────────────────────────────────────────────
function drawCell(c, x, y, alpha, isGhost) {
  const col = COLORS[c];
  const px = x * BLOCK, py = y * BLOCK;
  if (isGhost) {
    ctx.fillStyle = `rgba(${hexToRgb(col.fill)},0.12)`;
    ctx.strokeStyle = `rgba(${hexToRgb(col.fill)},0.35)`;
    ctx.lineWidth = 1;
    ctx.fillRect(px+1, py+1, BLOCK-2, BLOCK-2);
    ctx.strokeRect(px+1.5, py+1.5, BLOCK-3, BLOCK-3);
    return;
  }
  // Main fill
  const grad = ctx.createLinearGradient(px, py, px+BLOCK, py+BLOCK);
  grad.addColorStop(0, col.fill);
  grad.addColorStop(1, shadeColor(col.fill, -30));
  ctx.fillStyle = grad;
  ctx.fillRect(px+1, py+1, BLOCK-2, BLOCK-2);

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.fillRect(px+2, py+2, BLOCK-4, 4);
  ctx.fillRect(px+2, py+2, 4, BLOCK-4);

  // Glow
  ctx.shadowColor = col.glow;
  ctx.shadowBlur = 8;
  ctx.fillStyle = col.fill;
  ctx.fillRect(px+1, py+1, BLOCK-2, BLOCK-2);
  ctx.shadowBlur = 0;
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return `${r},${g},${b}`;
}

function shadeColor(hex, amt) {
  const n = parseInt(hex.slice(1),16);
  const r = Math.min(255,Math.max(0,(n>>16)+amt));
  const g = Math.min(255,Math.max(0,((n>>8)&0xff)+amt));
  const b = Math.min(255,Math.max(0,(n&0xff)+amt));
  return `#${((r<<16)|(g<<8)|b).toString(16).padStart(6,'0')}`;
}

function ghostY() {
  let gy = current.y;
  while (!collides(current, 0, gy - current.y + 1)) gy++;
  return gy;
}

function draw() {
  // Background
  ctx.fillStyle = '#060810';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  for (let r = 0; r <= ROWS; r++) {
    ctx.beginPath(); ctx.moveTo(0, r*BLOCK); ctx.lineTo(COLS*BLOCK, r*BLOCK); ctx.stroke();
  }
  for (let c = 0; c <= COLS; c++) {
    ctx.beginPath(); ctx.moveTo(c*BLOCK, 0); ctx.lineTo(c*BLOCK, ROWS*BLOCK); ctx.stroke();
  }

  // Board
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c]) drawCell(board[r][c], c, r);
    }
  }

  if (!gameOver && current) {
    // Ghost
    const gy = ghostY();
    for (let r = 0; r < current.shape.length; r++) {
      for (let c = 0; c < current.shape[r].length; c++) {
        if (current.shape[r][c]) drawCell(current.type, current.x+c, gy+r, 0.15, true);
      }
    }
    // Current
    for (let r = 0; r < current.shape.length; r++) {
      for (let c = 0; c < current.shape[r].length; c++) {
        if (current.shape[r][c]) drawCell(current.type, current.x+c, current.y+r);
      }
    }
  }

  // Next
  nextCtx.fillStyle = '#0a0f1e';
  nextCtx.fillRect(0,0,128,128);
  if (next) {
    const s = next.shape, cols = s[0].length, rows = s.length;
    const ox = Math.floor((4 - cols) / 2);
    const oy = Math.floor((4 - rows) / 2);
    const nb = 26;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (!s[r][c]) continue;
        const col = COLORS[next.type];
        const px = (ox+c)*nb + 12, py = (oy+r)*nb + 12;
        const grad = nextCtx.createLinearGradient(px, py, px+nb, py+nb);
        grad.addColorStop(0, col.fill);
        grad.addColorStop(1, shadeColor(col.fill, -30));
        nextCtx.fillStyle = grad;
        nextCtx.fillRect(px+1, py+1, nb-2, nb-2);
        nextCtx.fillStyle = 'rgba(255,255,255,0.25)';
        nextCtx.fillRect(px+2, py+2, nb-4, 3);
        nextCtx.shadowColor = col.glow;
        nextCtx.shadowBlur = 6;
        nextCtx.fillStyle = col.fill;
        nextCtx.fillRect(px+1, py+1, nb-2, nb-2);
        nextCtx.shadowBlur = 0;
      }
    }
  }
}

// ─── Loop ─────────────────────────────────────────────────────
function loop(ts) {
  if (!paused && !gameOver) {
    // Timer countdown
    const elapsed = ts - lastTimeTick;
    lastTimeTick = ts;
    timeLeft -= elapsed / 1000;
    updateTimer();
    if (timeLeft <= 0) {
      timeLeft = 0;
      if (score > hiScore) { hiScore = score; localStorage.setItem('tetrix_hi', hiScore); }
      updateUI();
      showResult('timeup');
      return;
    }

    if (ts - lastDrop > dropInterval) {
      moveDown();
      lastDrop = ts;
    }
  } else if (paused) {
    lastTimeTick = ts; // freeze timer while paused
  }
  draw();
  animId = requestAnimationFrame(loop);
}

// ─── Input ────────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (paused && e.code !== 'KeyP') return;
  switch(e.code) {
    case 'ArrowLeft':  e.preventDefault(); moveLeft(); break;
    case 'ArrowRight': e.preventDefault(); moveRight(); break;
    case 'ArrowDown':  e.preventDefault(); moveDown(); lastDrop = performance.now(); break;
    case 'ArrowUp':    e.preventDefault(); rotatePiece(); break;
    case 'Space':      e.preventDefault(); hardDrop(); break;
    case 'KeyP':
      if (!gameOver) {
        paused = !paused;
        if (!paused) { lastDrop = performance.now(); lastTimeTick = performance.now(); }
      }
      break;
  }
});

// Touch / mobile buttons
const touchMap = {
  'btn-left':   () => moveLeft(),
  'btn-right':  () => moveRight(),
  'btn-down':   () => { moveDown(); lastDrop = performance.now(); },
  'btn-rotate': () => rotatePiece(),
  'btn-drop':   () => hardDrop(),
};
Object.entries(touchMap).forEach(([id, fn]) => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('touchstart', e => { e.preventDefault(); if (!paused) fn(); }, { passive: false });
    el.addEventListener('mousedown', e => { e.preventDefault(); if (!paused) fn(); });
  }
});

// Start button
document.getElementById('start-btn').addEventListener('click', () => {
  const ov = document.getElementById('overlay');
  ov.classList.add('hidden');
  // Reset overlay state
  const title = document.getElementById('overlay-title');
  title.classList.remove('gameover');
  title.style.color = '';
  title.style.textShadow = '';
  title.textContent = 'TETRIX';
  document.getElementById('overlay-sub').textContent = 'PRESS START TO PLAY';
  document.getElementById('overlay-result').style.display = 'none';
  document.getElementById('overlay-stats').style.display = 'none';
  document.getElementById('overlay-hi-msg').style.display = 'none';
  document.getElementById('start-btn').textContent = 'START';
  init();
});

// Initial draw before start
(function initialDraw() {
  ctx.fillStyle = '#060810';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  nextCtx.fillStyle = '#0a0f1e';
  nextCtx.fillRect(0,0,128,128);
  document.getElementById('hi-display').textContent = localStorage.getItem('tetrix_hi') || '0';
})();
</script>
</body>
</html>
